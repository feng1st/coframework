package io.codeone.framework.chain;

import io.codeone.framework.chain.extension.Interference;
import io.codeone.framework.chain.graph.Graph;
import io.codeone.framework.chain.model.Context;
import io.codeone.framework.chain.node.Node;
import io.codeone.framework.chain.state.AsyncChainState;
import io.codeone.framework.chain.state.ChainState;
import io.codeone.framework.chain.state.SyncChainState;
import io.codeone.framework.logging.Log;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.concurrent.Executor;

/**
 * A chain of operations, which are performed by {@link Node}s, on a target.
 *
 * @param <T> The type of the target.
 */
@RequiredArgsConstructor(staticName = "of")
@Slf4j
public class Chain<T> {

    private final ChainSpec spec;

    private final Graph<Node> nodeGraph;

    /**
     * Executes the chain without an initial context, which means the target
     * should be generated by its nodes, and there is no input arguments.
     *
     * @return the final value of the target.
     */
    public T execute() {
        return execute(Context.ofEmpty());
    }

    public T execute(Interference interference) {
        return execute(Context.ofEmpty(), interference);
    }

    public T execute(Context<T> context, Interference interference) {
        return execute(interference.interfere(context));
    }

    /**
     * Executes the chain, with a context witch can include the initial target
     * and input arguments.
     * <p>
     * The nodes of the chain, in a graph, will be executed in a topological
     * order.
     *
     * @return the final value of the target.
     */
    @SneakyThrows(InterruptedException.class)
    public T execute(Context<T> context) {
        logChain(context);

        ChainState state = SyncChainState.of(nodeGraph);

        loop:
        while (state.isRunning()) {
            List<Node> nodes = state.pullNodes();
            for (Node node : nodes) {
                if (executeNode(context, node)) {
                    break loop;
                }
                state.finishNode(node, false);
            }
        }

        return context.getTarget();
    }

    /**
     * Executes the chain asynchronously, without an initial context, which
     * means the target should be generated by its nodes, and there is no input
     * arguments.
     *
     * @return the final value of the target.
     */
    public T executeAsync(Executor executor) throws InterruptedException {
        return executeAsync(Context.ofEmpty(), executor);
    }

    public T executeAsync(Interference interference, Executor executor)
            throws InterruptedException {
        return executeAsync(Context.ofEmpty(), interference, executor);
    }

    public T executeAsync(Context<T> context, Interference interference, Executor executor)
            throws InterruptedException {
        return executeAsync(interference.interfere(context), executor);
    }

    /**
     * Executes the chain asynchronously, with a context witch can include the
     * initial target and input arguments.
     * <p>
     * The nodes of the chain, in a graph, will be executed in a topological
     * order. And all nodes that do not depend on each other will be executed
     * simultaneously.
     *
     * @return the final value of the target.
     */
    public T executeAsync(Context<T> context, Executor executor) throws InterruptedException {
        logChain(context);

        ChainState state = AsyncChainState.of(nodeGraph);

        while (state.isRunning()) {
            List<Node> nodes = state.pullNodes();
            for (Node node : nodes) {
                executor.execute(() -> {
                    try {
                        state.finishNode(node, executeNode(context, node));
                    } catch (Throwable t) {
                        state.finishNode(node, true);
                        throw t;
                    }
                });
            }
            state.waitNodes();
        }

        return context.getTarget();
    }

    private void logChain(Context<T> context) {
        Log chainLog = Log.newBuilder()
                .logger(log)
                .scene(spec.getName().toString());
        context.log(chainLog::addArg);
        chainLog.success().log();
    }

    private boolean executeNode(Context<T> context, Node node) {
        Log nodeLog = Log.newBuilder()
                .logger(log)
                .scene(spec.getName().toString())
                .method(node.getClass().getSimpleName());
        long start = System.currentTimeMillis();
        try {
            if (node.execute(context, nodeLog::addArg)) {
                nodeLog.success(true);
                return true;
            }
            nodeLog.success(false);
            return false;
        } catch (Throwable t) {
            nodeLog.error(t);
            throw t;
        } finally {
            nodeLog.elapsed(System.currentTimeMillis() - start).log();
        }
    }
}
